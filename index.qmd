---
title: "RWD Training Inventory"
format: 
  html:
    page-layout: full
---

```{r setup}
#| include: false

# Load required libraries
library(googlesheets4)
library(googledrive)
library(dplyr)
library(ggplot2)
library(plotly)
library(lubridate)
library(tidyr)
library(scales)
library(RColorBrewer)

# Disable authentication for public sheets
gs4_deauth()
drive_deauth()

# Helper function to parse CSV-style quoted strings from Google Sheets
parse_csv_string <- function(x) {
  # Handle NA or empty strings
  if (is.na(x) || x == "") return(character(0))
  # Split on commas that are not inside quotes
  # This regex splits on commas not inside quoted sections
  parsed <- unlist(strsplit(x, ",(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)", perl = TRUE))
  # Remove quotes and trim whitespace
  parsed <- gsub('^\\s*"?|"?\\s*$', '', parsed)
  # Handle escaped quotes
  parsed <- gsub('\\\\"', '"', parsed)
  return(trimws(parsed))
}

format_latest_meta_time <- function(df, column_name, sheet_tz = "UTC") {
  if (!column_name %in% names(df)) return("Not configured")

  values <- df[[column_name]]
  parsed <- NULL

  if (inherits(values, c("POSIXct", "POSIXt"))) {
    parsed <- as.POSIXct(values, tz = "UTC")
  } else if (inherits(values, "Date")) {
    parsed <- as.POSIXct(values, tz = "UTC")
  } else {
    text <- trimws(as.character(values))
    text[text == ""] <- NA
    text <- ifelse(grepl("Z$", text), sub("Z$", "+0000", text), text)
    text <- gsub("([+-][0-9]{2}):([0-9]{2})$", "\\1\\2", text)
    parsed <- suppressWarnings(as.POSIXct(
      text,
      tz = "UTC",
      tryFormats = c(
        "%Y-%m-%dT%H:%M:%OS%z",
        "%Y-%m-%dT%H:%M:%OS",
        "%Y-%m-%d %H:%M:%OS",
        "%Y/%m/%d %H:%M:%OS",
        "%m/%d/%Y %H:%M:%OS",
        "%m/%d/%Y %H:%M",
        "%Y-%m-%d"
      )
    ))
  }

  parsed <- parsed[!is.na(parsed)]
  if (length(parsed) == 0) return("Unavailable")

  latest <- with_tz(max(parsed), tzone = sheet_tz)
  format(latest, "%B %d, %Y at %I:%M %p %Z")
}
```

::: {.dashboard-header}
# Real-World Data Training Resource Inventory
### Interactive Dashboard

Explore educational and training Real World Data resources from across CTSA institutions and beyond.
:::

```{=html}
<div class="intro-modal" id="intro-modal" aria-hidden="true">
  <div class="intro-modal-backdrop" data-close-intro></div>
  <div class="intro-modal-dialog" role="dialog" aria-modal="true" aria-labelledby="intro-modal-title">
    <button type="button" class="intro-modal-close" id="intro-modal-close" aria-label="Close">Ã—</button>
    <h2 id="intro-modal-title">Welcome to the CTSA RWD Inventory</h2>
    <p>
      This inventory highlights educational assets that support real-world data training across CTSA hubs, CTRs, and related communities.
    </p>
    <p>
      Want to add a resource? Use the <b>Submit Resource</b> link in the top menu to contribute new entries.
    </p>
    <div class="intro-modal-actions">
      <button type="button" class="intro-continue-btn" id="intro-modal-continue">Continue to the Inventory</button>
    </div>
  </div>
</div>
```

```{r load-data}
#| cache: false

# RWD Working Group Inventory Google Sheet
SHEET_URL <- "https://docs.google.com/spreadsheets/d/1L8VTkbA0bsEYAceLyYebYPxwETYyF2jzdvoCuqibE-s/edit?gid=0#gid=0"

# Load data from Google Sheets
tryCatch({
  # Read the Inventory tab (skip first row which is headers grouping)
  data_raw <- read_sheet(SHEET_URL, sheet = "Inventory", skip = 1)
  normalized_names <- trimws(names(data_raw))
  names(data_raw) <- normalized_names
  meta_created_col <- names(data_raw)[tolower(normalized_names) == "meta created at"][1]
  meta_updated_col <- names(data_raw)[tolower(normalized_names) == "meta updated at"][1]
  meta_url_status_col <- names(data_raw)[tolower(normalized_names) == "meta url status"][1]
  meta_url_checked_col <- names(data_raw)[tolower(normalized_names) == "meta url checked at"][1]
  meta_url_detail_col <- names(data_raw)[tolower(normalized_names) == "meta url check detail"][1]
  
  # Clean up the data - remove completely empty rows
  data <- data_raw %>%
    filter(!is.na(Title) & Title != "" & Title != "Title") %>%
    mutate(
      `Meta Created At` = if (!is.na(meta_created_col)) .data[[meta_created_col]] else NA_character_,
      `Meta Updated At` = if (!is.na(meta_updated_col)) .data[[meta_updated_col]] else NA_character_,
      `Meta URL Status` = if (!is.na(meta_url_status_col)) .data[[meta_url_status_col]] else NA_character_,
      `Meta URL Checked At` = if (!is.na(meta_url_checked_col)) .data[[meta_url_checked_col]] else NA_character_,
      `Meta URL Check Detail` = if (!is.na(meta_url_detail_col)) .data[[meta_url_detail_col]] else NA_character_
    ) %>%
    # Select key columns of interest
    select(
      Title,
      Type,
      Topic,
      Organization,
      `RWD Type`,
      `URL(s)`,
      Description,
      `Intended Audience`,
      Availability = starts_with("Availability"),
      `Meta Created At`,
      `Meta Updated At`,
      `Meta URL Status`,
      `Meta URL Checked At`,
      `Meta URL Check Detail`
    )
  
}, error = function(e) {
  stop(paste("Error loading data from Google Sheets:", e$message, 
             "\nMake sure the sheet is public and the URL is correct."))
})

if (!"Meta Created At" %in% names(data)) data$`Meta Created At` <- NA_character_
if (!"Meta Updated At" %in% names(data)) data$`Meta Updated At` <- NA_character_
if (!"Meta URL Status" %in% names(data)) data$`Meta URL Status` <- NA_character_
if (!"Meta URL Checked At" %in% names(data)) data$`Meta URL Checked At` <- NA_character_
if (!"Meta URL Check Detail" %in% names(data)) data$`Meta URL Check Detail` <- NA_character_

# Data freshness indicators
sheet_last_modified <- "Unavailable"
sheet_tz <- "UTC"
latest_row_created <- "Not configured"
latest_row_updated <- "Not configured"

tryCatch({
  sheet_meta <- gs4_get(SHEET_URL)
  sheet_tz <- if (!is.null(sheet_meta$time_zone) && nzchar(sheet_meta$time_zone)) sheet_meta$time_zone else "UTC"
  drive_info <- drive_get(as_id(sheet_meta$spreadsheet_id))
  modified_raw <- drive_info$drive_resource[[1]]$modifiedTime

  if (!is.null(modified_raw) && nzchar(modified_raw)) {
    modified_time <- with_tz(ymd_hms(modified_raw, tz = "UTC"), tzone = sheet_tz)
    sheet_last_modified <- format(modified_time, "%B %d, %Y at %I:%M %p %Z")
  }
}, error = function(e) {
  sheet_last_modified <<- "Unavailable"
})

latest_row_created <- if (exists("meta_created_col") && !is.na(meta_created_col)) {
  format_latest_meta_time(data_raw, meta_created_col, sheet_tz)
} else {
  "Not configured"
}
latest_row_updated <- if (exists("meta_updated_col") && !is.na(meta_updated_col)) {
  format_latest_meta_time(data_raw, meta_updated_col, sheet_tz)
} else {
  "Not configured"
}

# Get last update time
last_update <- format(Sys.time(), "%B %d, %Y at %I:%M %p %Z")
```

::: {.metrics-grid}

::: {.metric-card}
<div class="metric-label">Total Resources</div>
<div class="metric-value" id="metric-total-resources">`r nrow(data)`</div>
:::

::: {.metric-card}
<div class="metric-label">Organizations</div>
<div class="metric-value" id="metric-organizations">`r length(unique(data$Organization[!is.na(data$Organization)]))`</div>
:::

::: {.metric-card}
<div class="metric-label">RWD Types</div>
<div class="metric-value" id="metric-rwd-types">`r length(unique(data$Type[!is.na(data$Type)]))`</div>
:::

::: {.metric-card}
<div class="metric-label">RWD Topics</div>
<div class="metric-value" id="metric-rwd-topics">`r length(unique(unlist(strsplit(paste(data$Topic[!is.na(data$Topic)], collapse = ", "), ", "))))`</div>
:::

:::

```{=html}
<div id="plot-filter-panel" class="plot-filter-panel" style="display:none;">
  <div class="plot-filter-header">
    <strong>Chart Filters Active</strong>
    <span id="plot-filter-summary"></span>
  </div>
  <div id="plot-filter-chips" class="plot-filter-chips"></div>
  <div class="plot-filter-actions">
    <button id="plot-filter-clear" type="button" class="btn btn-sm btn-outline-secondary">Clear filters</button>
    <button id="plot-filter-jump" type="button" class="btn btn-sm btn-primary">Jump to table</button>
  </div>
</div>
```

### By RWD Type

::: {.chart-container}
```{r plot-rwd-types}
#| fig-width: 10
#| fig-height: 5

# Parse and count RWD Types (they may be comma-separated with quotes)
rwd_types_parsed <- data %>%
  filter(!is.na(`RWD Type`) & `RWD Type` != "") %>%
  rowwise() %>%
  mutate(RWD_list = list(parse_csv_string(`RWD Type`))) %>%
  ungroup() %>%
  select(-`RWD Type`) %>%  # Remove original column before unnesting
  unnest(RWD_list)

rwd_types <- rwd_types_parsed %>%
  count(RWD_list, sort = TRUE, name = "n") %>%
  rename(`RWD Type` = RWD_list) %>%
  head(12) %>%
  arrange(n)  # Sort for plotly

# Create color gradient
colors <- colorRampPalette(c("#3498db", "#2c3e50"))(nrow(rwd_types))

rwd_plot <- plot_ly(rwd_types, 
                    x = ~n, 
                    y = ~`RWD Type`, 
                    type = 'bar',
                    orientation = 'h',
                    marker = list(color = colors),
                    text = ~paste0(`RWD Type`, ": ", n, " resources"),
                    hoverinfo = 'text') %>%
  layout(title = list(text = "Resources by RWD Type",
                      font = list(size = 16)),
         xaxis = list(title = "Count"),
         yaxis = list(title = "", categoryorder = "total ascending", showticklabels = FALSE),
         hovermode = "closest",
         showlegend = FALSE,
         margin = list(l = 80))

rwd_plot$elementId <- "rwd-type-plot"
rwd_plot
```
:::

### Availability

::: {.chart-container}
```{r plot-availability}
#| fig-width: 10
#| fig-height: 5

# Count by availability - handle Google Sheets CSV-style quoting
availability_parsed <- data %>%
  filter(!is.na(Availability) & Availability != "") %>%
  rowwise() %>%
  mutate(Availability_list = list(parse_csv_string(Availability))) %>%
  ungroup() %>%
  select(-Availability) %>%  # Remove original column before unnesting
  unnest(Availability_list) %>%
  rename(Availability = Availability_list)

# Count and plot
availability <- availability_parsed %>%
  count(Availability, sort = TRUE) %>%
  mutate(Availability = reorder(Availability, n))

# Use native plotly for better pie chart
availability_plot <- plot_ly(availability, 
                             labels = ~Availability, 
                             values = ~n, 
                             type = 'pie',
                             hole = 0.55,
                             textposition = 'inside',
                             text = ~ifelse(n >= 5, as.character(n), ""),
                             textinfo = 'text',
                             hovertemplate = "%{label}<br>Count: %{value}<extra></extra>",
                             marker = list(colors = RColorBrewer::brewer.pal(n = nrow(availability), name = "Set3"))) %>%
  layout(title = list(text = "Resources by Availability", 
                      font = list(size = 16, family = "sans-serif")),
                      showlegend = TRUE,
         legend = list(orientation = "v"))

availability_plot$elementId <- "availability-plot"
availability_plot
```
:::

### By RWD Topic

::: {.chart-container}
```{r plot-topics}
#| fig-width: 10
#| fig-height: 6

# Parse and count Topics (they may be comma-separated with quotes)
topics_parsed <- data %>%
  filter(!is.na(Topic) & Topic != "") %>%
  rowwise() %>%
  mutate(Topic_list = list(parse_csv_string(Topic))) %>%
  ungroup() %>%
  select(-Topic) %>%  # Remove original column before unnesting
  unnest(Topic_list)

topics <- topics_parsed %>%
  count(Topic_list, sort = TRUE, name = "n") %>%
  rename(Topic = Topic_list) %>%
  head(15) %>%
  arrange(n)  # Sort for plotly

topic_plot <- plot_ly(topics, 
                      x = ~n, 
                      y = ~Topic, 
                      type = 'bar',
                      orientation = 'h',
                      marker = list(color = '#27ae60'),
                      text = ~paste0(Topic, ": ", n, " resources"),
                      hoverinfo = 'text') %>%
  layout(title = list(text = "Top 15 Topics",
                      font = list(size = 16)),
         xaxis = list(title = "Number of Resources"),
         yaxis = list(title = "", categoryorder = "total ascending", showticklabels = FALSE),
         hovermode = "closest",
         margin = list(l = 80))

topic_plot$elementId <- "topic-plot"
topic_plot
```
:::

### By Organization

::: {.chart-container}
```{r plot-organizations}
#| fig-width: 10
#| fig-height: 6

# Count resources by organization
org_counts_raw <- data %>%
  filter(!is.na(Organization) & Organization != "") %>%
  count(Organization, sort = TRUE)

# Separate organizations with 1 resource vs. more than 1
org_counts <- org_counts_raw %>%
  mutate(DisplayOrg = ifelse(n == 1, "Other", Organization)) %>%
  group_by(DisplayOrg) %>%
  summarise(n = sum(n), .groups = 'drop')

# Count how many institutions are in "Other" and update label
other_count <- sum(org_counts_raw$n == 1)
other_row <- org_counts %>% filter(DisplayOrg == "Other")

# Separate "Other" from the rest and sort
org_counts_without_other <- org_counts %>% 
  filter(DisplayOrg != "Other") %>%
  arrange(n)  # Sort ascending by count

org_counts_other <- org_counts %>% 
  filter(DisplayOrg == "Other") %>%
  mutate(DisplayOrg = paste0("Other (", other_count, " institutions)"))

# Put "Other" at the bottom (first in the list for ascending order)
org_counts <- bind_rows(org_counts_other, org_counts_without_other)

org_plot <- plot_ly(org_counts, 
                    x = ~n, 
                    y = ~DisplayOrg, 
                    type = 'bar',
                    orientation = 'h',
                    marker = list(color = '#3498db'),
                    textposition = 'auto',
                    insidetextfont = list(color = '#f8fafc'),
                    outsidetextfont = list(color = '#2c3e50'),
                    text = ~paste0(DisplayOrg, ": ", n, " resources"),
                    hoverinfo = 'text') %>%
  layout(title = list(text = "Organizations by Resource Count",
                      font = list(size = 16)),
         xaxis = list(title = "Number of Resources"),
         yaxis = list(title = "", categoryorder = "array", 
                      categoryarray = org_counts$DisplayOrg,
                      showticklabels = FALSE),
         hovermode = "closest",
         margin = list(l = 80))

org_plot$elementId <- "org-count-plot"
org_plot
```
:::

## Inventory Table

::: {.chart-container}
```{r data-table}
library(DT)

# Helper for display-safe values
safe_text <- function(x) {
  ifelse(is.na(x) | trimws(x) == "", "Not provided", as.character(htmltools::htmlEscape(x)))
}

url_status_chip <- function(x) {
  raw <- tolower(trimws(as.character(x)))
  status <- ifelse(raw %in% c("ok", "dead", "warn"), raw, "unknown")
  label <- dplyr::case_when(
    status == "ok" ~ "Links: OK",
    status == "dead" ~ "Links: Dead",
    status == "warn" ~ "Links: Warn",
    TRUE ~ "Links: Unknown"
  )
  paste0(
    '<span class="url-status-chip status-', status, '" title="', label, '">',
    '<span class="url-status-dot"></span>',
    label,
    '</span>'
  )
}

detail_row_if_present <- function(label, value, empty_text = "Unknown") {
  display_value <- as.character(value)
  if (is.na(value) || trimws(display_value) == "") display_value <- empty_text
  paste0(
    '<div class="detail-row"><span class="detail-label">', label,
    '</span><span class="detail-value">', as.character(htmltools::htmlEscape(display_value)), '</span></div>'
  )
}

parse_meta_datetime <- function(x) {
  text <- as.character(x)
  text[is.na(text) | trimws(text) == ""] <- NA_character_
  text <- ifelse(grepl("Z$", text), sub("Z$", "+0000", text), text)
  text <- gsub("([+-][0-9]{2}):([0-9]{2})$", "\\1\\2", text)
  suppressWarnings(as.POSIXct(
    text,
    tz = "UTC",
    tryFormats = c(
      "%Y-%m-%dT%H:%M:%OS%z",
      "%Y-%m-%dT%H:%M:%OS",
      "%Y-%m-%d %H:%M:%OS",
      "%Y/%m/%d %H:%M:%OS",
      "%m/%d/%Y %H:%M:%OS",
      "%m/%d/%Y %H:%M",
      "%Y-%m-%d"
    )
  ))
}

combine_latest_datetime <- function(created, updated) {
  out <- mapply(function(cdt, udt) {
    vals <- c(cdt, udt)
    vals <- vals[!is.na(vals)]
    if (length(vals) == 0) return(NA_real_)
    as.numeric(max(vals))
  }, created, updated)
  as.POSIXct(out, origin = "1970-01-01", tz = "UTC")
}

render_urls_html <- function(x) {
  urls <- parse_csv_string(x)
  urls <- urls[nzchar(trimws(urls))]
  if (length(urls) == 0) return("Unknown")
  paste(vapply(urls, function(url) {
    safe <- as.character(htmltools::htmlEscape(url))
    sprintf('<a href="%s" target="_blank" rel="noopener noreferrer">%s</a>', safe, safe)
  }, character(1)), collapse = "<br>")
}

# Build compact rows plus expandable details
data_display <- data %>%
  mutate(
    Sheet_Row_Order = row_number(),
    Created_Parsed = parse_meta_datetime(`Meta Created At`),
    Updated_Parsed = parse_meta_datetime(`Meta Updated At`),
    Date_Added_Parsed = combine_latest_datetime(Created_Parsed, Updated_Parsed),
    Date_Added = ifelse(
      is.na(Date_Added_Parsed),
      "Unknown",
      format(with_tz(Date_Added_Parsed, tzone = sheet_tz), "%Y-%m-%d")
    ),
    First_URL = vapply(`URL(s)`, function(x) {
      parsed <- parse_csv_string(x)
      if (length(parsed) > 0) parsed[[1]] else NA_character_
    }, character(1)),
    Title_Tooltip = ifelse(
      is.na(Description) | trimws(Description) == "",
      "No description provided",
      as.character(htmltools::htmlEscape(Description))
    ),
    Title_Cell = paste0(
      '<div class="inventory-title" title="', Title_Tooltip, '">', safe_text(Title), '</div>',
      '<div class="inventory-meta">',
      url_status_chip(`Meta URL Status`),
      '<span class="meta-chip">Type: ', safe_text(Type), '</span>',
      '<span class="meta-chip">RWD: ', safe_text(`RWD Type`), '</span>',
      '<span class="meta-chip">Availability: ', safe_text(Availability), '</span>',
      '</div>'
    ),
    Details = paste0(
      '<div class="resource-details">',
      '<div class="detail-row"><span class="detail-label">Topic</span><span class="detail-value">', safe_text(Topic), '</span></div>',
      '<div class="detail-row"><span class="detail-label">Description</span><span class="detail-value">', safe_text(Description), '</span></div>',
      '<div class="detail-row"><span class="detail-label">RWD Type</span><span class="detail-value">', safe_text(`RWD Type`), '</span></div>',
      '<div class="detail-row"><span class="detail-label">Intended Audience</span><span class="detail-value">', safe_text(`Intended Audience`), '</span></div>',
      '<div class="detail-row"><span class="detail-label">URLs</span><span class="detail-value">', vapply(`URL(s)`, render_urls_html, character(1)), '</span></div>',
      vapply(seq_along(Title), function(i) detail_row_if_present("Created", `Meta Created At`[[i]]), character(1)),
      vapply(seq_along(Title), function(i) detail_row_if_present("Last Updated", `Meta Updated At`[[i]]), character(1)),
      '</div>'
    )
  ) %>%
  transmute(
    Sheet_Row_Order,
    Date_Added_Parsed,
    Title = Title_Cell,
    Organization = safe_text(Organization),
    `Date Added` = Date_Added,
    Type = safe_text(Type),
    Availability = safe_text(Availability),
    `RWD Type` = safe_text(`RWD Type`),
    Topic = safe_text(Topic),
    Details
  ) %>%
  arrange(is.na(Date_Added_Parsed), desc(Date_Added_Parsed), desc(Sheet_Row_Order)) %>%
  select(-Sheet_Row_Order, -Date_Added_Parsed)

datatable(
  data_display,
  extensions = 'Buttons',
  escape = FALSE,
  elementId = "resource-table",
  options = list(
    dom = 'Bfrtip',
    buttons = c('copy', 'csv', 'excel'),
    paging = FALSE,
    scrollX = TRUE,
    scrollY = "560px",
    scrollCollapse = TRUE,
    order = list(),
    columnDefs = list(
      list(width = '54%', targets = 0),
      list(width = '26%', targets = 1),
      list(width = '10%', targets = 2),
      list(visible = FALSE, targets = c(3, 4, 5, 6, 7))
    )
  ),
  callback = JS(
    "table.on('click', 'tbody td', function(e) {",
    "  if ($(e.target).closest('a, button, input').length) return;",
    "  var tr = $(this).closest('tr');",
    "  if (tr.hasClass('child')) return;",
    "  var row = table.row(tr);",
    "  if (row.child.isShown()) {",
    "    row.child.hide();",
    "    tr.removeClass('shown');",
    "  } else {",
    "    row.child(row.data()[7]).show();",
    "    tr.addClass('shown');",
    "  }",
    "});"
  ),
  filter = "top",
  class = 'cell-border stripe hover compact inventory-table',
  rownames = FALSE,
  colnames = c('Title', 'Organization', 'Date Added', 'Type', 'Availability', 'RWD Type', 'Topic', 'Details')
)
```
:::

```{=html}
<script>
document.addEventListener("DOMContentLoaded", function () {
  const SHEET_ID = "1L8VTkbA0bsEYAceLyYebYPxwETYyF2jzdvoCuqibE-s";
  const SHEET_NAME = "Inventory";
  const GVIZ_URL = "https://docs.google.com/spreadsheets/d/" + SHEET_ID +
    "/gviz/tq?sheet=" + encodeURIComponent(SHEET_NAME) +
    "&range=A2:ZZ&tq=&tqx=out:json";

  const metricTotal = document.getElementById("metric-total-resources");
  const metricOrg = document.getElementById("metric-organizations");
  const metricType = document.getElementById("metric-rwd-types");
  const metricTopic = document.getElementById("metric-rwd-topics");

  function parseGvizJson(text) {
    const start = text.indexOf("(");
    const end = text.lastIndexOf(")");
    if (start === -1 || end === -1 || end <= start) throw new Error("Invalid GViz response");
    return JSON.parse(text.slice(start + 1, end));
  }

  function normalizeHeader(name) {
    return String(name || "").toLowerCase().replace(/\s+/g, " ").trim();
  }

  function escapeHtml(value) {
    return String(value == null ? "" : value)
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;")
      .replace(/'/g, "&#39;");
  }

  function safeText(value, emptyText) {
    const text = String(value == null ? "" : value).trim();
    if (!text) return escapeHtml(emptyText || "Not provided");
    return escapeHtml(text);
  }

  function parseCsvLike(value) {
    const raw = String(value == null ? "" : value).trim();
    if (!raw) return [];
    return raw
      .split(/,(?=(?:[^"]*"[^"]*")*[^"]*$)/)
      .map(function (part) { return part.replace(/^\s*"?|"?\s*$/g, "").replace(/\\"/g, "\"").trim(); })
      .filter(Boolean);
  }

  function parseTimestamp(value) {
    const text = String(value == null ? "" : value).trim();
    if (!text) return null;
    const gvizDate = text.match(/^Date\((.+)\)$/);
    if (gvizDate) {
      const parts = gvizDate[1].split(",").map(function (x) { return parseInt(x.trim(), 10); });
      if (parts.length >= 3 && parts.every(function (x) { return !isNaN(x); })) {
        return new Date(Date.UTC(parts[0], parts[1], parts[2], parts[3] || 0, parts[4] || 0, parts[5] || 0));
      }
    }
    const parsed = new Date(text);
    return isNaN(parsed.getTime()) ? null : parsed;
  }

  function statusLabel(status) {
    if (status === "ok") return "Links: OK";
    if (status === "dead") return "Links: Dead";
    if (status === "warn") return "Links: Warn";
    return "Links: Unknown";
  }

  function statusChipHtml(statusRaw) {
    const s = (statusRaw === "ok" || statusRaw === "dead" || statusRaw === "warn") ? statusRaw : "unknown";
    return "<span class=\"url-status-chip status-" + s + "\" title=\"" + statusLabel(s) + "\"><span class=\"url-status-dot\"></span>" + statusLabel(s) + "</span>";
  }

  function renderUrlsHtml(raw) {
    const urls = parseCsvLike(raw);
    if (!urls.length) return "Unknown";
    return urls.map(function (u) {
      const safe = escapeHtml(u);
      return "<a href=\"" + safe + "\" target=\"_blank\" rel=\"noopener noreferrer\">" + safe + "</a>";
    }).join("<br>");
  }

  function firstUrl(raw) {
    const urls = parseCsvLike(raw);
    return urls.length ? urls[0] : "";
  }

  function buildDetails(record) {
    return [
      "<div class=\"resource-details\">",
      "<div class=\"detail-row\"><span class=\"detail-label\">Topic</span><span class=\"detail-value\">" + safeText(record.topic) + "</span></div>",
      "<div class=\"detail-row\"><span class=\"detail-label\">Description</span><span class=\"detail-value\">" + safeText(record.description) + "</span></div>",
      "<div class=\"detail-row\"><span class=\"detail-label\">RWD Type</span><span class=\"detail-value\">" + safeText(record.rwdType) + "</span></div>",
      "<div class=\"detail-row\"><span class=\"detail-label\">Intended Audience</span><span class=\"detail-value\">" + safeText(record.intendedAudience) + "</span></div>",
      "<div class=\"detail-row\"><span class=\"detail-label\">URLs</span><span class=\"detail-value\">" + renderUrlsHtml(record.urls) + "</span></div>",
      "<div class=\"detail-row\"><span class=\"detail-label\">Created</span><span class=\"detail-value\">" + safeText(record.metaCreated, "Unknown") + "</span></div>",
      "<div class=\"detail-row\"><span class=\"detail-label\">Last Updated</span><span class=\"detail-value\">" + safeText(record.metaUpdated, "Unknown") + "</span></div>",
      "</div>"
    ].join("");
  }

  function getDataTable() {
    if (!(window.jQuery && jQuery.fn.dataTable)) return null;
    const selector = "#resource-table table.dataTable";
    if (jQuery.fn.dataTable.isDataTable(selector)) return jQuery(selector).DataTable();
    const fallback = jQuery("#resource-table table");
    if (fallback.length && jQuery.fn.dataTable.isDataTable(fallback[0])) return jQuery(fallback[0]).DataTable();
    return null;
  }

  function colIndexMap(headers) {
    const normalized = headers.map(normalizeHeader);
    function idx(name) { return normalized.indexOf(normalizeHeader(name)); }
    return {
      title: idx("Title"),
      type: idx("Type"),
      topic: idx("Topic"),
      organization: idx("Organization"),
      rwdType: idx("RWD Type"),
      urls: idx("URL(s)"),
      description: idx("Description"),
      intendedAudience: idx("Intended Audience"),
      availability: idx("Availability"),
      metaCreated: idx("Meta Created At"),
      metaUpdated: idx("Meta Updated At"),
      metaUrlStatus: idx("Meta URL Status")
    };
  }

  fetch(GVIZ_URL)
    .then(function (response) {
      if (!response.ok) throw new Error("Failed to load sheet data");
      return response.text();
    })
    .then(function (text) {
      const parsed = parseGvizJson(text);
      const table = parsed.table || {};
      const cols = table.cols || [];
      const rows = table.rows || [];
      let headers = cols.map(function (c) { return (c && c.label) ? String(c.label).trim() : ""; });
      let dataRows = rows;

      if (!headers.some(function (h) { return h; }) && rows.length > 0) {
        const headerCells = rows[0].c || [];
        headers = headerCells.map(function (cell, i) {
          const v = cell && (cell.f !== undefined && cell.f !== null ? cell.f : cell.v);
          return v === undefined || v === null ? ("Column " + (i + 1)) : String(v).trim();
        });
        dataRows = rows.slice(1);
      }

      const idx = colIndexMap(headers);
      if (idx.title < 0) return;

      const records = dataRows.map(function (row) {
        const cells = row && row.c ? row.c : [];
        function valueAt(i) {
          if (i < 0 || !cells[i]) return "";
          const cell = cells[i];
          const value = (cell.v !== undefined && cell.v !== null) ? cell.v : cell.f;
          return value == null ? "" : String(value);
        }
        return {
          title: valueAt(idx.title).trim(),
          type: valueAt(idx.type),
          topic: valueAt(idx.topic),
          organization: valueAt(idx.organization),
          rwdType: valueAt(idx.rwdType),
          urls: valueAt(idx.urls),
          description: valueAt(idx.description),
          intendedAudience: valueAt(idx.intendedAudience),
          availability: valueAt(idx.availability),
          metaCreated: valueAt(idx.metaCreated),
          metaUpdated: valueAt(idx.metaUpdated),
          metaUrlStatus: valueAt(idx.metaUrlStatus).trim().toLowerCase()
        };
      }).filter(function (r) {
        return r.title && r.title !== "Title";
      });

      const tableRows = records.map(function (r, idx) {
        const createdDate = parseTimestamp(r.metaCreated);
        const updatedDate = parseTimestamp(r.metaUpdated);
        const latest = [createdDate, updatedDate].filter(Boolean).sort(function (a, b) { return b - a; })[0];
        const dateAdded = latest ? latest.toISOString().slice(0, 10) : "Unknown";
        const titleTooltip = r.description && r.description.trim() ? escapeHtml(r.description) : "No description provided";
        const titleCell = [
          "<div class=\"inventory-title\" title=\"" + titleTooltip + "\">" + safeText(r.title) + "</div>",
          "<div class=\"inventory-meta\">",
          statusChipHtml(r.metaUrlStatus),
          "<span class=\"meta-chip\">Type: " + safeText(r.type) + "</span>",
          "<span class=\"meta-chip\">RWD: " + safeText(r.rwdType) + "</span>",
          "<span class=\"meta-chip\">Availability: " + safeText(r.availability) + "</span>",
          "</div>"
        ].join("");
        return {
          row: [
            titleCell,
            safeText(r.organization),
            escapeHtml(dateAdded),
            safeText(r.type),
            safeText(r.availability),
            safeText(r.rwdType),
            safeText(r.topic),
            buildDetails(r)
          ],
          latest: latest,
          rowOrder: idx
        };
      }).sort(function (a, b) {
        const aHasDate = !!a.latest;
        const bHasDate = !!b.latest;
        if (aHasDate !== bHasDate) return aHasDate ? -1 : 1;
        if (aHasDate && bHasDate) {
          const dateDiff = b.latest - a.latest;
          if (dateDiff !== 0) return dateDiff;
        }
        return b.rowOrder - a.rowOrder;
      }).map(function (x) { return x.row; });

      const tableApi = getDataTable();
      if (tableApi) {
        tableApi.clear();
        tableApi.rows.add(tableRows);
        tableApi.draw(false);
      }

      if (metricTotal) metricTotal.textContent = String(records.length);

      if (metricOrg) {
        const orgCount = new Set(records.map(function (r) { return r.organization.trim(); }).filter(Boolean)).size;
        metricOrg.textContent = String(orgCount);
      }

      if (metricType) {
        const typeCount = new Set(records.map(function (r) { return r.type.trim(); }).filter(Boolean)).size;
        metricType.textContent = String(typeCount);
      }

      if (metricTopic) {
        const topics = new Set();
        records.forEach(function (r) {
          parseCsvLike(r.topic).forEach(function (t) { topics.add(t); });
        });
        metricTopic.textContent = String(topics.size);
      }

      const clearBtn = document.getElementById("plot-filter-clear");
      if (clearBtn) clearBtn.click();
    })
    .catch(function () {
      // Keep server-rendered table/metrics as fallback.
    });
});
</script>
```

```{=html}
<script>
document.addEventListener("DOMContentLoaded", function () {
  const state = { organization: null, rwdType: null, topic: null, availability: null };
  const panel = document.getElementById("plot-filter-panel");
  const chips = document.getElementById("plot-filter-chips");
  const summary = document.getElementById("plot-filter-summary");
  const clearBtn = document.getElementById("plot-filter-clear");
  const jumpBtn = document.getElementById("plot-filter-jump");

  if (!panel || !chips || !summary || !clearBtn || !jumpBtn) return;

  const escapeRegex = (value) => value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  const hasFilter = () => Boolean(state.organization || state.rwdType || state.topic || state.availability);

  function getTable() {
    if (!(window.jQuery && jQuery.fn.dataTable)) return null;
    const selector = "#resource-table table.dataTable";
    if (jQuery.fn.dataTable.isDataTable(selector)) return jQuery(selector).DataTable();
    const fallback = jQuery("#resource-table table");
    if (fallback.length && jQuery.fn.dataTable.isDataTable(fallback[0])) return jQuery(fallback[0]).DataTable();
    return null;
  }

  function stripHtml(value) {
    const tmp = document.createElement("div");
    tmp.innerHTML = value == null ? "" : String(value);
    return (tmp.textContent || tmp.innerText || "").trim();
  }

  function parseCsvLike(value) {
    if (!value) return [];
    const parts = String(value).split(/,(?=(?:[^"]*"[^"]*")*[^"]*$)/);
    return parts
      .map(function (part) {
        return part.replace(/^\s*"?|"?\s*$/g, "").replace(/\\"/g, "\"").trim();
      })
      .filter(Boolean);
  }

  function toHex(n) {
    const clamped = Math.max(0, Math.min(255, Math.round(n)));
    return clamped.toString(16).padStart(2, "0");
  }

  function buildGradient(n) {
    if (n <= 0) return [];
    if (n === 1) return ["#2c3e50"];
    const start = [52, 152, 219];
    const end = [44, 62, 80];
    const colors = [];
    for (let i = 0; i < n; i++) {
      const t = i / (n - 1);
      const r = start[0] + (end[0] - start[0]) * t;
      const g = start[1] + (end[1] - start[1]) * t;
      const b = start[2] + (end[2] - start[2]) * t;
      colors.push("#" + toHex(r) + toHex(g) + toHex(b));
    }
    return colors;
  }

  function buildOrgData(rows) {
    const counts = {};
    rows.forEach(function (row) {
      const org = stripHtml(row[1]);
      if (!org || org === "Not provided") return;
      counts[org] = (counts[org] || 0) + 1;
    });

    const entries = Object.entries(counts);
    const singles = entries.filter(function (entry) { return entry[1] === 1; }).length;
    const regular = entries
      .filter(function (entry) { return entry[1] > 1; })
      .sort(function (a, b) {
        if (a[1] !== b[1]) return a[1] - b[1];
        return a[0].localeCompare(b[0]);
      });

    const labels = [];
    const values = [];
    if (singles > 0) {
      labels.push("Other (" + singles + " institutions)");
      values.push(singles);
    }
    regular.forEach(function (entry) {
      labels.push(entry[0]);
      values.push(entry[1]);
    });

    const text = labels.map(function (label, i) {
      return label + ": " + values[i] + " resources";
    });
    return { labels: labels, values: values, text: text };
  }

  function buildRwdData(rows) {
    const counts = {};
    rows.forEach(function (row) {
      const raw = stripHtml(row[5]);
      if (!raw || raw === "Not provided") return;
      parseCsvLike(raw).forEach(function (item) {
        counts[item] = (counts[item] || 0) + 1;
      });
    });

    const entries = Object.entries(counts).sort(function (a, b) {
      if (a[1] !== b[1]) return a[1] - b[1];
      return a[0].localeCompare(b[0]);
    });
    const labels = entries.map(function (entry) { return entry[0]; });
    const values = entries.map(function (entry) { return entry[1]; });
    const text = entries.map(function (entry) { return entry[0] + ": " + entry[1] + " resources"; });
    return { labels: labels, values: values, text: text, colors: buildGradient(entries.length) };
  }

  function buildTopicData(rows) {
    const counts = {};
    rows.forEach(function (row) {
      const raw = stripHtml(row[6]);
      if (!raw || raw === "Not provided") return;
      parseCsvLike(raw).forEach(function (item) {
        counts[item] = (counts[item] || 0) + 1;
      });
    });

    const top = Object.entries(counts)
      .sort(function (a, b) {
        if (a[1] !== b[1]) return b[1] - a[1];
        return a[0].localeCompare(b[0]);
      })
      .slice(0, 15)
      .sort(function (a, b) {
        if (a[1] !== b[1]) return a[1] - b[1];
        return a[0].localeCompare(b[0]);
      });

    const labels = top.map(function (entry) { return entry[0]; });
    const values = top.map(function (entry) { return entry[1]; });
    const text = top.map(function (entry) { return entry[0] + ": " + entry[1] + " resources"; });
    return { labels: labels, values: values, text: text };
  }

  function buildAvailabilityData(rows) {
    const counts = {};
    rows.forEach(function (row) {
      const raw = stripHtml(row[4]);
      if (!raw || raw === "Not provided") return;
      parseCsvLike(raw).forEach(function (item) {
        counts[item] = (counts[item] || 0) + 1;
      });
    });

    const entries = Object.entries(counts).sort(function (a, b) {
      if (a[1] !== b[1]) return b[1] - a[1];
      return a[0].localeCompare(b[0]);
    });
    return {
      labels: entries.map(function (entry) { return entry[0]; }),
      values: entries.map(function (entry) { return entry[1]; }),
      total: entries.reduce(function (acc, entry) { return acc + entry[1]; }, 0)
    };
  }

  function updatePlots(table) {
    if (!table || !window.Plotly) return;
    const rows = table.rows({ search: "applied" }).data().toArray();

    const org = buildOrgData(rows);
    const orgPlot = document.getElementById("org-count-plot");
    if (orgPlot) {
      Plotly.restyle(orgPlot, { x: [org.values], y: [org.labels], text: [org.text] }, [0]);
      Plotly.relayout(orgPlot, { "yaxis.categoryarray": org.labels });
    }

    const rwd = buildRwdData(rows);
    const rwdPlot = document.getElementById("rwd-type-plot");
    if (rwdPlot) {
      Plotly.restyle(rwdPlot, { x: [rwd.values], y: [rwd.labels], text: [rwd.text], "marker.color": [rwd.colors] }, [0]);
      Plotly.relayout(rwdPlot, { "yaxis.categoryarray": rwd.labels });
    }

    const topic = buildTopicData(rows);
    const topicPlot = document.getElementById("topic-plot");
    if (topicPlot) {
      Plotly.restyle(topicPlot, { x: [topic.values], y: [topic.labels], text: [topic.text] }, [0]);
      Plotly.relayout(topicPlot, { "yaxis.categoryarray": topic.labels });
    }

    const availability = buildAvailabilityData(rows);
    const availabilityPlot = document.getElementById("availability-plot");
    if (availabilityPlot) {
      const availabilityText = availability.values.map(function (value) {
        return value >= 5 ? String(value) : "";
      });
      Plotly.restyle(availabilityPlot, { labels: [availability.labels], values: [availability.values], text: [availabilityText] }, [0]);
    }
  }

  function renderPanel() {
    if (!hasFilter()) {
      panel.style.display = "none";
      chips.innerHTML = "";
      summary.textContent = "";
      return;
    }

    const chipHtml = [];
    if (state.organization) chipHtml.push("<span class='plot-filter-chip'>Organization: " + state.organization + "</span>");
    if (state.rwdType) chipHtml.push("<span class='plot-filter-chip'>RWD Type: " + state.rwdType + "</span>");
    if (state.topic) chipHtml.push("<span class='plot-filter-chip'>Topic: " + state.topic + "</span>");
    if (state.availability) chipHtml.push("<span class='plot-filter-chip'>Availability: " + state.availability + "</span>");
    chips.innerHTML = chipHtml.join("");
    panel.style.display = "block";

    const table = getTable();
    if (!table) return;
    const count = table.rows({ filter: "applied" }).count();
    summary.textContent = "Showing " + count + " matching resources";
  }

  function applyFilters() {
    const table = getTable();
    if (!table) return;

    table.column(1).search(
      state.organization ? "^" + escapeRegex(state.organization) + "$" : "",
      true,
      false
    );
    table.column(5).search(
      state.rwdType ? escapeRegex(state.rwdType) : "",
      true,
      false
    );
    table.column(6).search(
      state.topic ? escapeRegex(state.topic) : "",
      true,
      false
    );
    table.column(4).search(
      state.availability ? escapeRegex(state.availability) : "",
      true,
      false
    );
    table.draw();
    updatePlots(table);
    renderPanel();
  }

  function bindPlotClick(plotId, onSelect) {
    const plotEl = document.getElementById(plotId);
    if (!plotEl || plotEl.__rwdBound) return false;
    plotEl.on("plotly_click", function (eventData) {
      const point = eventData && eventData.points && eventData.points[0];
      if (!point) return;
      onSelect(point);
      applyFilters();
    });
    plotEl.__rwdBound = true;
    return true;
  }

  function tryBindPlots() {
    const orgBound = bindPlotClick("org-count-plot", function (point) {
      const selected = point.y;
      if (typeof selected !== "string") return;
      if (selected.indexOf("Other (") === 0) return;
      state.organization = state.organization === selected ? null : selected;
    });

    const rwdBound = bindPlotClick("rwd-type-plot", function (point) {
      const selected = point.y;
      if (typeof selected !== "string") return;
      state.rwdType = state.rwdType === selected ? null : selected;
    });

    const topicBound = bindPlotClick("topic-plot", function (point) {
      const selected = point.y;
      if (typeof selected !== "string") return;
      state.topic = state.topic === selected ? null : selected;
    });

    const availabilityBound = bindPlotClick("availability-plot", function (point) {
      const selected = point.label;
      if (typeof selected !== "string") return;
      state.availability = state.availability === selected ? null : selected;
    });

    if (orgBound && rwdBound && topicBound && availabilityBound) clearInterval(bindIntervalId);
  }

  clearBtn.addEventListener("click", function () {
    state.organization = null;
    state.rwdType = null;
    state.topic = null;
    state.availability = null;
    applyFilters();
  });

  jumpBtn.addEventListener("click", function () {
    const tableEl = document.getElementById("resource-table");
    if (tableEl) tableEl.scrollIntoView({ behavior: "smooth", block: "start" });
  });

  const bindIntervalId = setInterval(tryBindPlots, 300);
  const tableIntervalId = setInterval(function () {
    const table = getTable();
    if (table) {
      updatePlots(table);
      renderPanel();
      clearInterval(tableIntervalId);
    }
  }, 300);
  setTimeout(function () { clearInterval(bindIntervalId); }, 10000);
  setTimeout(function () { clearInterval(tableIntervalId); }, 10000);
});
</script>
```

```{=html}
<script>
document.addEventListener("DOMContentLoaded", function () {
  const sheetModifiedEl = document.getElementById("sheet-last-modified");
  const latestCreatedEl = document.getElementById("latest-row-created");
  const latestUpdatedEl = document.getElementById("latest-row-updated");
  const deadLinksEl = document.getElementById("dead-links-count");
  if (!latestCreatedEl && !latestUpdatedEl && !sheetModifiedEl && !deadLinksEl) return;

  const SHEET_ID = "1L8VTkbA0bsEYAceLyYebYPxwETYyF2jzdvoCuqibE-s";
  const SHEET_NAME = "Inventory";
  const GVIZ_URL = "https://docs.google.com/spreadsheets/d/" + SHEET_ID +
    "/gviz/tq?sheet=" + encodeURIComponent(SHEET_NAME) +
    "&range=A2:ZZ&tq=&tqx=out:json";

  function parseGvizJson(text) {
    const start = text.indexOf("(");
    const end = text.lastIndexOf(")");
    if (start === -1 || end === -1 || end <= start) throw new Error("Invalid GViz response");
    return JSON.parse(text.slice(start + 1, end));
  }

  function parseTimestamp(value) {
    if (value === null || value === undefined) return null;
    const text = String(value).trim();
    if (!text) return null;

    const gvizDate = text.match(/^Date\((.+)\)$/);
    if (gvizDate) {
      const parts = gvizDate[1].split(",").map(function (x) { return parseInt(x.trim(), 10); });
      if (parts.length >= 3 && parts.every(function (x) { return !isNaN(x); })) {
        return new Date(Date.UTC(
          parts[0], parts[1], parts[2], parts[3] || 0, parts[4] || 0, parts[5] || 0
        ));
      }
    }

    const parsed = new Date(text);
    if (isNaN(parsed.getTime())) return null;
    return parsed;
  }

  function formatDate(date) {
    return date.toLocaleString(undefined, {
      year: "numeric",
      month: "long",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      timeZoneName: "short"
    });
  }

  function normalizeKey(title, org) {
    const t = (title || "").toLowerCase().replace(/\s+/g, " ").trim();
    const o = (org || "").toLowerCase().replace(/\s+/g, " ").trim();
    return t + "||" + o;
  }

  function stripHtml(value) {
    const tmp = document.createElement("div");
    tmp.innerHTML = value == null ? "" : String(value);
    return (tmp.textContent || tmp.innerText || "").trim();
  }

  function statusLabel(status) {
    if (status === "ok") return "Links: OK";
    if (status === "dead") return "Links: Dead";
    if (status === "warn") return "Links: Warn";
    return "Links: Unknown";
  }

  function makeStatusChip(status) {
    const s = (status === "ok" || status === "dead" || status === "warn") ? status : "unknown";
    return "<span class=\"url-status-chip status-" + s + "\" title=\"" + statusLabel(s) + "\"><span class=\"url-status-dot\"></span>" + statusLabel(s) + "</span>";
  }

  function updateDetailValue(detailsHtml, label, value) {
    const wrapper = document.createElement("div");
    wrapper.innerHTML = detailsHtml || "";
    const rows = wrapper.querySelectorAll(".detail-row");
    rows.forEach(function (row) {
      const labelEl = row.querySelector(".detail-label");
      const valueEl = row.querySelector(".detail-value");
      if (!labelEl || !valueEl) return;
      if (labelEl.textContent.trim() === label) valueEl.textContent = value;
    });
    return wrapper.innerHTML;
  }

  function getDataTable() {
    if (!(window.jQuery && jQuery.fn.dataTable)) return null;
    const selector = "#resource-table table.dataTable";
    if (jQuery.fn.dataTable.isDataTable(selector)) return jQuery(selector).DataTable();
    const fallback = jQuery("#resource-table table");
    if (fallback.length && jQuery.fn.dataTable.isDataTable(fallback[0])) return jQuery(fallback[0]).DataTable();
    return null;
  }

  fetch(GVIZ_URL)
    .then(function (response) {
      if (!response.ok) throw new Error("Failed to load sheet data");
      return response.text();
    })
    .then(function (text) {
      const parsed = parseGvizJson(text);
      const table = parsed.table || {};
      const cols = table.cols || [];
      const rows = table.rows || [];

      let dataRows = rows;
      let colNames = cols.map(function (c) { return (c && c.label ? String(c.label).trim() : ""); });
      let createdIdx = colNames.indexOf("Meta Created At");
      let updatedIdx = colNames.indexOf("Meta Updated At");
      let titleIdx = colNames.indexOf("Title");
      let orgIdx = colNames.indexOf("Organization");
      let statusIdx = colNames.indexOf("Meta URL Status");
      let checkedIdx = colNames.indexOf("Meta URL Checked At");
      let detailIdx = colNames.indexOf("Meta URL Check Detail");

      // Fallback: some GViz responses expose headers as the first data row.
      if ((createdIdx < 0 || updatedIdx < 0 || statusIdx < 0) && rows.length > 0) {
        const firstRowCells = rows[0].c || [];
        const headerFromFirstRow = firstRowCells.map(function (cell) {
          const value = cell && (cell.f !== undefined && cell.f !== null ? cell.f : cell.v);
          return value === undefined || value === null ? "" : String(value).trim();
        });
        const fallbackCreatedIdx = headerFromFirstRow.indexOf("Meta Created At");
        const fallbackUpdatedIdx = headerFromFirstRow.indexOf("Meta Updated At");
        const fallbackTitleIdx = headerFromFirstRow.indexOf("Title");
        const fallbackOrgIdx = headerFromFirstRow.indexOf("Organization");
        const fallbackStatusIdx = headerFromFirstRow.indexOf("Meta URL Status");
        const fallbackCheckedIdx = headerFromFirstRow.indexOf("Meta URL Checked At");
        const fallbackDetailIdx = headerFromFirstRow.indexOf("Meta URL Check Detail");
        if (fallbackCreatedIdx >= 0 || fallbackUpdatedIdx >= 0 || fallbackStatusIdx >= 0) {
          createdIdx = fallbackCreatedIdx;
          updatedIdx = fallbackUpdatedIdx;
          titleIdx = fallbackTitleIdx;
          orgIdx = fallbackOrgIdx;
          statusIdx = fallbackStatusIdx;
          checkedIdx = fallbackCheckedIdx;
          detailIdx = fallbackDetailIdx;
          dataRows = rows.slice(1);
        }
      }

      let latestCreated = null;
      let latestUpdated = null;
      let deadCount = 0;
      const rowMeta = {};

      dataRows.forEach(function (row) {
        const cells = (row && row.c) ? row.c : [];
        const titleVal = titleIdx >= 0 && cells[titleIdx] ? (cells[titleIdx].v || cells[titleIdx].f || "") : "";
        const orgVal = orgIdx >= 0 && cells[orgIdx] ? (cells[orgIdx].v || cells[orgIdx].f || "") : "";
        const statusRaw = statusIdx >= 0 && cells[statusIdx] ? (cells[statusIdx].v || cells[statusIdx].f || "") : "";
        const checkedRaw = checkedIdx >= 0 && cells[checkedIdx] ? (cells[checkedIdx].v || cells[checkedIdx].f || "") : "";
        const detailRaw = detailIdx >= 0 && cells[detailIdx] ? (cells[detailIdx].v || cells[detailIdx].f || "") : "";
        const status = String(statusRaw || "").trim().toLowerCase();
        if (status === "dead") deadCount += 1;
        if (titleVal) {
          rowMeta[normalizeKey(String(titleVal), String(orgVal))] = {
            status: status || "unknown",
            checkedAt: String(checkedRaw || "").trim() || "Unknown",
            detail: String(detailRaw || "").trim() || "Unknown"
          };
        }

        if (createdIdx >= 0) {
          const createdVal = cells[createdIdx] ? cells[createdIdx].v : null;
          const createdDate = parseTimestamp(createdVal);
          if (createdDate && (!latestCreated || createdDate > latestCreated)) latestCreated = createdDate;
        }
        if (updatedIdx >= 0) {
          const updatedVal = cells[updatedIdx] ? cells[updatedIdx].v : null;
          const updatedDate = parseTimestamp(updatedVal);
          if (updatedDate && (!latestUpdated || updatedDate > latestUpdated)) latestUpdated = updatedDate;
        }
      });

      if (latestCreatedEl && createdIdx >= 0) {
        latestCreatedEl.textContent = latestCreated ? formatDate(latestCreated) : "Unavailable";
      } else if (latestCreatedEl) {
        latestCreatedEl.textContent = "Not configured";
      }

      if (latestUpdatedEl && updatedIdx >= 0) {
        latestUpdatedEl.textContent = latestUpdated ? formatDate(latestUpdated) : "Unavailable";
      } else if (latestUpdatedEl) {
        latestUpdatedEl.textContent = "Not configured";
      }

      if (sheetModifiedEl) {
        const mostRecent = [latestCreated, latestUpdated]
          .filter(function (d) { return d instanceof Date; })
          .sort(function (a, b) { return b - a; })[0];
        if (mostRecent) sheetModifiedEl.textContent = formatDate(mostRecent);
      }

      if (deadLinksEl && statusIdx >= 0) deadLinksEl.textContent = String(deadCount);

      if (statusIdx >= 0) {
        const tryApply = function () {
          const table = getDataTable();
          if (!table) return false;

          const indexes = table.rows().indexes().toArray();
          indexes.forEach(function (idx) {
            const rowData = table.row(idx).data();
            if (!rowData || !rowData.length) return;

            const titleText = stripHtml(rowData[0]).split("\n")[0].trim();
            const orgText = stripHtml(rowData[1]);
            const meta = rowMeta[normalizeKey(titleText, orgText)] || rowMeta[normalizeKey(titleText, "")];
            if (!meta) return;

            const titleWrap = document.createElement("div");
            titleWrap.innerHTML = rowData[0];
            const chip = titleWrap.querySelector(".url-status-chip");
            if (chip) chip.outerHTML = makeStatusChip(meta.status);
            rowData[0] = titleWrap.innerHTML;

            table.row(idx).data(rowData);
          });
          table.draw(false);
          return true;
        };

        const pollId = setInterval(function () {
          if (tryApply()) clearInterval(pollId);
        }, 300);
        setTimeout(function () { clearInterval(pollId); }, 10000);
      }
    })
    .catch(function () {
      // Keep server-rendered fallback values if live fetch fails.
    });
});
</script>
```

```{=html}
<script>
document.addEventListener("DOMContentLoaded", function () {
  const modal = document.getElementById("intro-modal");
  const closeBtn = document.getElementById("intro-modal-close");
  const continueBtn = document.getElementById("intro-modal-continue");
  const SEEN_KEY = "rwd_inventory_intro_seen_v1";
  let lastFocused = null;

  if (!modal) return;

  function markSeen() {
    try {
      localStorage.setItem(SEEN_KEY, "1");
    } catch (error) {
      // no-op; if storage is blocked, modal may show again on next visit
    }
  }

  function hasSeen() {
    try {
      return localStorage.getItem(SEEN_KEY) === "1";
    } catch (error) {
      return false;
    }
  }

  function shouldForceShow() {
    try {
      const params = new URLSearchParams(window.location.search || "");
      return params.get("showIntro") === "1";
    } catch (error) {
      return false;
    }
  }

  function openModal() {
    lastFocused = document.activeElement;
    modal.classList.add("is-open");
    modal.setAttribute("aria-hidden", "false");
    document.body.classList.add("intro-modal-open");
    if (continueBtn) continueBtn.focus();
  }

  function closeModal() {
    markSeen();
    modal.classList.remove("is-open");
    modal.setAttribute("aria-hidden", "true");
    document.body.classList.remove("intro-modal-open");
    if (lastFocused && typeof lastFocused.focus === "function") lastFocused.focus();
  }

  if (shouldForceShow() || !hasSeen()) openModal();

  if (closeBtn) closeBtn.addEventListener("click", closeModal);
  if (continueBtn) continueBtn.addEventListener("click", closeModal);

  modal.addEventListener("click", function (event) {
    if (event.target && event.target.hasAttribute("data-close-intro")) {
      closeModal();
    }
  });

  document.addEventListener("keydown", function (event) {
    if (event.key === "Escape" && modal.classList.contains("is-open")) {
      closeModal();
    }
  });
});
</script>
```

::: {.last-updated}
Latest entry created: <span id="latest-row-created">`r latest_row_created`</span> <br /> Latest entry update: <span id="latest-row-updated">`r latest_row_updated`</span><br>
Page build updated: `r last_update`
:::
